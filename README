主要分为两部分
一、NDK、JNI部分熟悉Java和C++通信，eg:java调用C++，C++调用Java等；

Android 中Java和C、C++通信主要有两种方式
1）静态注册：通过Java+全类名+方法名,同时.变成/;
2）动态注册：这种比较灵活，常用，Android系统也是通过这种方式；
动态注册的方式：https://blog.csdn.net/xiaoyu_93/article/details/52861173
动态注册 无法打印log;


1）、JNIEnv参数解析：https://www.cnblogs.com/lenve/p/4781605.html?utm_source=tuicool&utm_medium=referral
JNIEnv是指向可用JNI函数表的接口指针，原生代码通过JNIEnv接口指针提供的各种函数来使用虚拟机的功能。JNIEnv是一个指向线程-局部数据的指针，而线程-局部数据中包含指向线程表的指针。
实现原生方法的函数将JNIEnv接口指针作为它们的第一个参数。

原生代码是C以及原生代码是C++其调用JNI函数的语法不同，C代码中，JNIEnv是指向JNINativeInterface结构的指针，为了访问任何一个JNI函数，该指针需要首先被解引用。
在C++代码中，JNIEnv实际上是C++类实例，JNI函数以成员函数形式存在，因为JNI方法已经访问了当前的JNI环境

2）C++ 字符串处理：https://blog.csdn.net/u013834525/article/details/82533935

3）Java访问C++，包含有参，无参，有返回值等各种情况；

4）CMakeLists.txt配置：
   1)https://blog.csdn.net/u012528526/article/details/80647537
   2)https://blog.csdn.net/afei__/article/details/81201039

5)实现秒表的功能
  1）C、C++和Java相互调用；
  2）由于秒表可以长时间计时，主线程无法做耗时操作，只能通过C、C++子线程去调用；
    创建线程的方法thread、pthread_create(https://www.jianshu.com/p/986d608a8a35)参数解析;
  3） JNIEnv 不能跨线程传递，可以通过AttachCurrentThread()、DetachCurrentThread()方法;
  4）每个进程都有一个JavaVM，统一进程内，所有的线程共用一个JavaVM;
  5）jobject、jclass、jmethodID这些类型无法在线程间共享，需要转换为全局变量。
     在JNI接口线程中将jobject转换为全局变量，在子线程通过JavaVM*获取JNIEnv*，并通过全局变量jobect获取jclass，从而得到jmethod。

6)如何管理第三方C、C++包



二、FFmpeg的编译和在Android的应用；
1）Android 编译FFmpeg和NDK版本、FFmpeg的版本以及编译so的架构都有关系；
具体参考https://codezjx.com/2019/06/21/compile-ffmpeg-android/
或者将根目录下build_android.sh放入ffmpeg 目录下，执行

2）视频转码并保存：https://blog.csdn.net/ethanco/article/details/83447554

三、C、C++的区别
1）C没有类的概念，也就没有public等访问修饰符，也没有继承等；C不允许使用默认参数，不定长度参数前必须有正常参数，